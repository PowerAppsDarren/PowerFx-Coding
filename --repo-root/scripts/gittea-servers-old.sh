#!/bin/bash

# Enhanced Git Tea Server Setup Script
# This script initializes a Git repository for Tea server projects with interactive prompts,
# .gitignore handling, and secure remote pushes. Fixes include SSH for backup remote,
# dynamic branch detection for pushes, and warnings for monorepo subdir usage.

set -euo pipefail

# Color definitions for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_status() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Interactive Initialization: Prompt for project name
print_status "Welcome to the enhanced Git Tea Server Setup!"
echo -e "${BLUE}ðŸš€ Git Tea Server Setup${NC}"

# Prompt for GIT_PROJECT_NAME with validation
GIT_PROJECT_NAME=""
while [[ -z "$GIT_PROJECT_NAME" ]]; do
    read -p "Enter the project name: " GIT_PROJECT_NAME
    if [[ -z "$GIT_PROJECT_NAME" ]]; then
        print_warning "Project name cannot be empty. Please try again."
    fi
done

print_status "Project name set to: $GIT_PROJECT_NAME"

# Working Directory Confirmation
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PARENT_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"

echo -e "\n${BLUE}Working Directory Selection${NC}"
echo "Option 1: Current script dir - $SCRIPT_DIR"
echo "Option 2: Parent dir - $PARENT_DIR"
echo "Please select (1 or 2): "

WORKING_DIR=""
while [[ -z "$WORKING_DIR" ]]; do
    read -r choice
    case "$choice" in
        1)
            WORKING_DIR="$SCRIPT_DIR"
            echo -e "\n${BLUE}Script Copy Option${NC}"
            read -p "Should the script be copied to a 'scripts/' folder in the working directory? (This folder may be created if it doesn't exist.) [y/N]: " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                mkdir -p "$WORKING_DIR/scripts"
                cp "$0" "$WORKING_DIR/scripts/git-tea-servers.sh"
                print_status "Script copied to $WORKING_DIR/scripts/git-tea-servers.sh"
            fi
            ;;
        2)
            WORKING_DIR="$PARENT_DIR"
            ;;
        *)
            print_warning "Invalid choice. Please enter 1 or 2."
            echo "Please select (1 or 2): "
            ;;
    esac
done

# Change to working directory
cd "$WORKING_DIR" || { print_error "Failed to change to working directory: $WORKING_DIR"; exit 1; }
print_status "Working in directory: $WORKING_DIR"

# Detect current branch for later pushes (fix for refspec mismatch)
BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "main")

# Git Repository Check and Initialization
print_status "Checking Git repository status..."

if ! git rev-parse --git-dir &>/dev/null; then
    git init
    print_status "Initialized new Git repository."
    BRANCH="main"  # Default for new repo
else
    print_status "Existing Git repository detected."
fi

echo -e "\n${BLUE}Current Git status:${NC}"
git status

# Warning for monorepo/subdir usage (addresses unresolved status issues)
if git ls-files --others --exclude-standard | grep -q "^\.\./" || git diff --name-only | grep -q "^\.\./"; then
    print_warning "Note: Untracked or modified files detected outside the current project directory (e.g., parent repo files). These are part of the broader repository. The script stages only project files. Update root .gitignore or commit them separately if needed."
fi

# .gitignore Handling
print_status "Handling .gitignore file..."

if [[ ! -f .gitignore ]] || [[ ! -s .gitignore ]]; then
    # Create .gitignore with common patterns for Tea server project (NO .env patterns)
    cat > .gitignore << 'EOF'
# Logs
logs
*.log
npm-debug.log*

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage

# nyc test coverage
.nyc_output

# Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
jspm_packages/

# TypeScript v1 declaration files
typings/

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next

# Nuxt.js build / generate output
.nuxt

# Gatsby files
.cache/
public

# VuePress build output
.vuepress/dist

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# Common project ignores
node_modules/
dist/
build/
*.tmp
.DS_Store
Thumbs.db
*.swp
*.swo
EOF
    print_status "Generated .gitignore with common Tea server patterns."
else
    print_status ".gitignore already exists and is not empty."
fi

# Display .gitignore contents and confirm
echo -e "\n${BLUE}Generated/updated .gitignore contents:${NC}"
cat .gitignore
echo
read -p "Proceed? [y/N]: " -n 1 -r
echo
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    print_status "Opening .gitignore for manual edit..."
    if command -v nano &>/dev/null; then
        nano .gitignore
    else
        vi .gitignore
    fi
    print_status "Manual edit complete. Proceeding."
fi

# Staging and Committing
print_status "Staging files..."

git add .

# Check if there are changes to commit
if git diff --staged --quiet; then
    print_warning "No changes to commit; proceeding to remotes."
else
    git commit -m "Initial commit: Set up ${GIT_PROJECT_NAME} project with .gitignore and basic structure"
    print_status "Committed changes for ${GIT_PROJECT_NAME}."
fi

# Existing Remote Configuration Logic (enhanced with dynamic naming and fixes)
print_status "ðŸ”§ Configuring Git remotes for $GIT_PROJECT_NAME"

# Preserve existing remote URLs but make dynamic with GIT_PROJECT_NAME
# Origin: Use expected GitHub URL if adding new; but don't overwrite if exists
ORIGIN_URL="https://github.com/user/${GIT_PROJECT_NAME}.git"

# Backup: Changed to SSH for secure auth (fixes HTTP Basic denied)
BACKUP_URL="git@gitlab.com:user/${GIT_PROJECT_NAME}.git"

# Add remotes if they don't exist
if ! git remote | grep -q origin; then
    git remote add origin "$ORIGIN_URL"
    print_status "Added origin remote: $ORIGIN_URL"
else
    print_status "Origin remote already exists (preserved for monorepo/subdir usage)."
fi

if ! git remote | grep -q backup; then
    git remote add backup "$BACKUP_URL"
    print_status "Added backup remote: $BACKUP_URL"
else
    print_status "Backup remote already exists."
fi

# Push to remotes using detected branch (fixes refspec mismatch)
print_status "Pushing ${GIT_PROJECT_NAME} to remotes (using branch: $BRANCH)..."

# Push to origin (if changes; handle existing tracking)
if git rev-parse --verify origin/$BRANCH &>/dev/null; then
    git push origin $BRANCH
else
    git push -u origin $BRANCH
fi
print_status "Pushed ${GIT_PROJECT_NAME} to origin successfully."

# Push to backup
if git rev-parse --verify backup/$BRANCH &>/dev/null; then
    git push backup $BRANCH
else
    git push -u backup $BRANCH
fi
print_status "Pushed ${GIT_PROJECT_NAME} to backup successfully."

# Summary
echo -e "\n${GREEN}ðŸŽ‰ Setup complete!${NC}"
print_status "Your ${GIT_PROJECT_NAME} repo is ready at $WORKING_DIR."
echo "Run 'git status' to verify."
print_status "Remotes configured:"
echo "- Origin: $(git remote get-url origin 2>/dev/null || echo $ORIGIN_URL)"
echo "- Backup: $(git remote get-url backup 2>/dev/null || echo $BACKUP_URL)"
